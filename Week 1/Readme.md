# Week - 1
---
### 1.1 Orientation and Environment Setup
### 1.2 JavaScript Foundation

1. [Why languages?](#1.-Why-languages)
2. [Interpreted vs compiled languages](#2.-Interpreted-vs-compiled-languages)
3. [Why JS >> Other languages in some use-cases](#Why-JS->>-Other-languages-in-some-use-cases)
4. [Strict vs dynamic languages](#Strict-vs-dynamic-languages)
5. [Single threaded nature of JS](#Single threaded nature of JS)
6. [Simple primitives in JS (number, strings, booleans)](#)
7. [Complex primitives in JS (arrays, objects)](#)
8. [Functions in Javascript](#Functions-in-Javascript)
9. [Practise problem solving](#)
10. [Callback functions, Event loop, callback queue, Asynchronous programming](#)
11. [Callback hell and Promises](#Callback-hell-and-Promises)

### 1. Why languages
- rom(hdd/ ssd) - application are resided inside rom
- ram - application when open run in ram
- Programmer write high level language 
- Every language has a complier to converts to binary language 0s and 1s
- machine only understand binary language(low level language)

complier works under the hood

### 2. Interpreted vs compiled languages
- lorem
- lorem
- lorem
### Why JS >> Other languages in some use-cases
### Strict vs dynamic languages
### Single threaded nature of JS
### Simple primitives in JS (number, strings, booleans)
### Complex primitives in JS (arrays, objects)
### Functions in Javascript
### Practise problem solving
### Callback functions, Event loop, callback queue, Asynchronous programming
### Callback hell and Promises